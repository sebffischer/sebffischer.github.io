{
  "hash": "d40cdc08089b0422ac78b9ae85a8c0f7",
  "result": {
    "markdown": "---\ntitle: \"Multiple Dispatch with S3\"\ndescription: \"Exploring the S3 class system in R\"\nauthor: \"Sebastian Fischer\"\ndate: \"1/26/2023\"\ndraft: true\n---\n\n\n\n\nR has different class systems that allow for object-oriented programming in the language.\nThe simplest of which is the S3 system, which selects a method for an object depending on its class.\n\nIn the simple example above, we write a generic function `scream()` that does something different for numerics and for \ncharacters.\n\n\n::: {.cell}\n\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nscream = function(x) {\n  UseMethod(\"scream\")\n}\n\nscream.numeric = function(x) {\n  print(\"THIS IS A NUMBER!!!\")\n}\n\nscream.character = function(x) {\n  print(\"THIS IS A CHARACTER!!!\")\n}\n\nscream(1)\n#> [1] \"THIS IS A NUMBER!!!\"\n\nscream(\"1\")\n#> [1] \"THIS IS A CHARACTER!!!\"\n```\n:::\n\n\n\nHowever, the S3 class system only allows for single dispatch, meaning that only the class of one object - by \ndefault the first argument - is used to select the method.\nThere can be cases, where it makes sense to dispatch on two elements.\nThe S4 class system - the successor of S3 - for example allows this.\nImplementing multiple dispatch is however also possible using only S3.\n\nWe might want to change our generic function above to take in two arguments `x` and `y` and scream something depending\non both of their classes. The neat trick that we will use for that is that of nested S3 functions. We then let the \nfirst dispatch happen on the class of the first argument and the second dispatch uses the class of the second element.\nI was made aware of this construct when reading the [debugadapter implementation](https://github.com/dgkf/debugadapter) \nfor R. \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nscream2 = function(x, y) {\n  UseMethod(\"scream2\")\n}\n\nscream2.numeric = function(x, y) {\n  UseMethod(\"scream2.numeric\", y)\n}\n\nscream2.character = function(x, y) {\n  UseMethod(\"scream2.character\", y)\n}\n\nscream2.numeric.character = function(x, y) {\n  print(\"THIS IS A numeric AND A CHARACTER!\")\n}\n\nscream2.character.numeric = function(x, y) { \n  print(\"THIS IS A CHARACTER AND AN NUMERIC!\")\n}\n\nscream2.numeric.numeric = function(x, y) {\n  print(\"THESE ARE TWO NUMERICS!\")\n}\n\nscream2.character.character = function(x, y) {\n  print(\"THESE ARE TWO CHARACTERS!\")\n}\n\nscream2(1, \"1\")\n#> [1] \"THIS IS A numeric AND A CHARACTER!\"\nscream2(\"1\", 1)\n#> [1] \"THIS IS A CHARACTER AND AN NUMERIC!\"\nscream2(1, 1)\n#> [1] \"THESE ARE TWO NUMERICS!\"\nscream2(\"1\", \"1\")\n#> [1] \"THESE ARE TWO CHARACTERS!\"\n```\n:::\n\n\nSo, what could go wrong by doing so?\nBecause of the way S3 works, i.e. the names of the methods have the form `<generic>.<class>` the function names that\nwe have used above are ambiguous. If someone decides to create an object of class `\"character.character\"` we have \naccidentally also created a method for this class.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nweird_object = structure(list(), class = \"character.character\")\n\nscream2(weird_object)\n#> [1] \"THESE ARE TWO CHARACTERS!\"\n```\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}